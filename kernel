inline float gaussian(const float mu,
                       const float sigma,
                       const float scale,
                       const float value)
{
    const float d = value - mu;
    //return scale * exp(-0.5f * d * d / (sigma * sigma));
    return scale / (1.0f + sigma * d * d);
}


__kernel void pso(__constant const float *paramsf, 
				  __constant const uint *paramsi,
				  __global const float *data, 
				  __constant const float *particle, 
				  __global float *out, 
				  __local float *lmem)
{
	// params float
	const float targetValue = paramsf[0];
	const float targetSigma = paramsf[1];
	const float minSigma = paramsf[2];
	
	// params uint
	const uint targetAhead = paramsi[0];
	const uint Window = paramsi[1];
	const uint Nodes = paramsi[2];	
	const uint localWindowSize = paramsi[3];
	
	// ids
	const uint gid = get_global_id(0);
	const uint lid = get_local_id(0);
	const uint los = get_local_size(0);
	const uint off = get_group_id(0) * los;
	
	// copy global to local memory
	for (uint i = 0; i < localWindowSize; i += los)
	{
		uint lidx = lid + i;		
		if (lidx >= localWindowSize)
		{
			lidx = lid;
		}	
		const uint gidx = off + lidx;
		lmem[lidx] = data[gidx];
	}
	//printf("%f %f\n", lmem[lid], data[gid]);
	barrier(CLK_LOCAL_MEM_FENCE);

	// normalize data window to 0-1
    float vmin = FLT_MAX,
          vmax = -FLT_MAX;
    for (uint k = 0; k < Window; ++k)
    {
        const uint idx = lid + k;
        if (lmem[idx] < vmin) vmin = lmem[idx];
        if (lmem[idx] > vmax) vmax = lmem[idx];
    }
    float scale;
    if (vmin == vmax)
    {
        scale = 1.0f;
        vmin -= 0.5f;
    }
    else
    {
        scale = 1.0f / (vmax - vmin);
    }

    // compute teacher
    const float teacher = gaussian(targetValue, targetSigma, 1.0f, scale * (lmem[lid + (Window - 1) + targetAhead] - vmin));
	//printf("%u %u\n", lid + (Window - 1) + targetAhead, localWindowSize);

	// kernel response
	float sum = 0.0f;
	uint counter = 0;
    for (uint i = 0; i < Window; ++i)
    {
        for (uint k = 0; k < Nodes; ++k)
        {
            sum += gaussian(particle[counter++],
                            fabs(particle[counter++]) + minSigma,
                            particle[counter++],
                            scale * (lmem[lid + i] - vmin));
        }
    }
    sum /= (float)(Window * Nodes);
	
	// compute error
	const float err = sum - teacher;	
	out[gid] = err * err;
	
	//uint bla = gid + Window + targetAhead - 1u;
	//printf("min=%f, max=%f, gid=%u, teach=%u, resp=%f, teacher=%f, mu=%f, sig=%f, sca=%f\n", vmin, vmax, gid, bla, sum, teacher, particle[0], fabs(particle[1]) + minSigma, particle[2]); 
}